import {
  ensureDirectoryExists,
  saveBinaryFile,
  uint8ArrayToBase64,
  getNodePath,
} from "./utils";
import { ImageOptions, Metadata } from "./types";

/**
 * Represents an image generated by NovelAI
 */
export class Image {
  /**
   * The filename of the image
   */
  readonly filename: string;

  /**
   * Raw binary image data
   */
  readonly data: Uint8Array;

  /**
   * Optional metadata used to generate the image
   */
  readonly metadata?: Metadata;

  /**
   * Create a new Image instance
   *
   * @param options - Configuration options for the image
   * @param options.filename - The filename of the image
   * @param options.data - Raw binary data of the image
   * @param options.metadata - Optional metadata used to generate the image
   */
  constructor(options: ImageOptions) {
    this.filename = options.filename;
    this.data = options.data;
    this.metadata = options.metadata;
  }

  /**
   * Get the size of the image in bytes
   */
  get size(): number {
    return this.data.byteLength;
  }

  /**
   * Convert the image data to a base64 string
   *
   * @returns Base64 encoded image data
   */
  toBase64(): string {
    return uint8ArrayToBase64(this.data);
  }

  /**
   * Create a data URL for the image
   *
   * @returns Data URL for the image (suitable for browser use)
   */
  toDataURL(): string {
    // Determine the MIME type based on file extension
    const mimeType = this.filename.toLowerCase().endsWith(".png")
      ? "image/png"
      : "image/jpeg";
    return `data:${mimeType};base64,${this.toBase64()}`;
  }

  /**
   * Save the image to disk (Node.js environment only)
   *
   * @param outputPath - Path to save the image to. If a directory is provided,
   *                     the image is saved with its original filename in that directory.
   * @returns Promise that resolves to the full path of the saved file
   */
  async save(outputPath: string): Promise<string> {
    if (typeof window !== "undefined") {
      throw new Error("save() is only available in Node.js environment");
    }

    try {
      // Get path module (Node.js only)
      const path = getNodePath();
      if (!path) {
        throw new Error("Path module not available");
      }

      // Check if output path is a directory or includes a filename
      let fullPath: string;
      if (outputPath.endsWith("/") || !path.extname(outputPath)) {
        // It's a directory, append the filename
        ensureDirectoryExists(outputPath);
        fullPath = path.join(outputPath, this.filename);
      } else {
        // It's a full file path
        ensureDirectoryExists(path.dirname(outputPath));
        fullPath = outputPath;
      }

      // Save the file
      saveBinaryFile(this.data, fullPath);
      return fullPath;
    } catch (error) {
      throw new Error(`Failed to save image: ${(error as Error).message}`);
    }
  }

  /**
   * Create a Blob from the image data (browser environment only)
   *
   * @returns Blob representing the image
   */
  toBlob(): Blob {
    if (typeof window === "undefined") {
      throw new Error("toBlob() is only available in browser environment");
    }

    // Determine the MIME type based on file extension
    const mimeType = this.filename.toLowerCase().endsWith(".png")
      ? "image/png"
      : "image/jpeg";
    return new Blob([this.data], { type: mimeType });
  }

  /**
   * Create a File object from the image data (browser environment only)
   *
   * @returns File object representing the image
   */
  toFile(): File {
    if (typeof window === "undefined") {
      throw new Error("toFile() is only available in browser environment");
    }

    // Determine the MIME type based on file extension
    const mimeType = this.filename.toLowerCase().endsWith(".png")
      ? "image/png"
      : "image/jpeg";
    return new File([this.data], this.filename, { type: mimeType });
  }
}
