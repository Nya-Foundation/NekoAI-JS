import {
  ensureDirectoryExists,
  saveBinaryFile,
  uint8ArrayToBase64,
  getNodePath,
} from "./utils";
import { ImageOptions } from "./types";

/**
 * Represents an image generated by NovelAI
 */
export class Image {
  /**
   * The filename of the image
   */
  readonly filename: string;

  /**
   * Raw binary image data
   */
  readonly data: Uint8Array;

  /**
   * Create a new Image instance
   *
   * @param options - Configuration options for the image
   * @param options.filename - The filename of the image
   * @param options.data - Raw binary data of the image
   */
  constructor(options: ImageOptions) {
    this.filename = options.filename;
    this.data = options.data;
  }

  /**
   * Get the size of the image in bytes
   */
  get size(): number {
    return this.data.byteLength;
  }

  /**
   * Convert the image data to a base64 string
   *
   * @returns Base64 encoded image data
   */
  toBase64(): string {
    return uint8ArrayToBase64(this.data);
  }

  /**
   * Create a data URL for the image
   *
   * @returns Data URL for the image (suitable for browser use)
   */
  toDataURL(): string {
    // Determine the MIME type based on file extension
    const mimeType = this.filename.toLowerCase().endsWith(".png")
      ? "image/png"
      : "image/jpeg";
    return `data:${mimeType};base64,${this.toBase64()}`;
  }

  /**
   * Save the image to disk (Node.js environment only)
   *
   * @param outputPath - Path to save the image to. If a directory is provided,
   *                     the image is saved with its original filename in that directory.
   * @returns Promise that resolves to the full path of the saved file
   */
  async save(outputPath: string): Promise<string> {
    if (typeof window !== "undefined") {
      throw new Error("save() is only available in Node.js environment");
    }

    try {
      // Get path module (Node.js only)
      const path = getNodePath();
      if (!path) {
        throw new Error("Path module not available");
      }

      // Check if output path is a directory or includes a filename
      let fullPath: string;
      if (outputPath.endsWith("/") || !path.extname(outputPath)) {
        // It's a directory, append the filename
        ensureDirectoryExists(outputPath);
        fullPath = path.join(outputPath, this.filename);
      } else {
        // It's a full file path
        ensureDirectoryExists(path.dirname(outputPath));
        fullPath = outputPath;
      }

      // Save the file
      saveBinaryFile(this.data, fullPath);
      return fullPath;
    } catch (error) {
      throw new Error(`Failed to save image: ${(error as Error).message}`);
    }
  }

  /**
   * Create a Blob from the image data (browser environment only)
   *
   * @returns Blob representing the image
   */
  toBlob(): Blob {
    if (typeof window === "undefined") {
      throw new Error("toBlob() is only available in browser environment");
    }

    // Determine the MIME type based on file extension
    const mimeType = this.filename.toLowerCase().endsWith(".png")
      ? "image/png"
      : "image/jpeg";
    return new Blob([this.data], { type: mimeType });
  }

  /**
   * Create a File object from the image data (browser environment only)
   *
   * @returns File object representing the image
   */
  toFile(): File {
    if (typeof window === "undefined") {
      throw new Error("toFile() is only available in browser environment");
    }

    // Determine the MIME type based on file extension
    const mimeType = this.filename.toLowerCase().endsWith(".png")
      ? "image/png"
      : "image/jpeg";
    return new File([this.data], this.filename, { type: mimeType });
  }
}

/**
 * Enum for event types in the msgpack event.
 */
export enum EventType {
  INTERMEDIATE = "intermediate",
  FINAL = "final",
}

/**
 * A single msgpack event object in the return of `generate_image` method or director tools.
 */
export class MsgpackEvent {
  /**
   * The type of event (intermediate or final)
   */
  readonly event_type: EventType;

  /**
   * Sample index
   */
  readonly samp_ix: number;

  /**
   * Step index
   */
  readonly step_ix: number;

  /**
   * Generation ID
   */
  readonly gen_id: string;

  /**
   * Sigma value
   */
  readonly sigma: number;

  /**
   * Image data (JPEG for intermediate, PNG for final)
   */
  readonly image: Image;

  constructor(options: {
    event_type: EventType;
    samp_ix: number;
    step_ix: number;
    gen_id: string;
    sigma: number;
    image: Image;
  }) {
    this.event_type = options.event_type;
    this.samp_ix = options.samp_ix;
    this.step_ix = options.step_ix;
    this.gen_id = options.gen_id;
    this.sigma = options.sigma;
    this.image = options.image;
  }

  toString(): string {
    return `MsgpackEvent(event_type=${this.event_type}, step_ix=${this.step_ix}, gen_id=${this.gen_id})`;
  }
}
